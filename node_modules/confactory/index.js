const dotProp = require('dot-prop')
const merge = require('blend.js')

function createFactory () {
  const helpers = []
  const hooks = []
  const targets = []

  const api = {
    get _helpers () {
      return helpers
    },
    get _hooks () {
      return hooks
    },
    get _targets () {
      return targets
    },
    $build (context, meta, config = {}) {
      if (typeof meta === 'function') {
        meta = meta(context, config)
      }
      hooks.forEach(({fn, elseFn, meta: hookMeta, metaKeys: hookMetaKeys}) => {
        const metaMatched = testMetaMatching(meta, hookMeta, hookMetaKeys)
        const hook = metaMatched ? fn : elseFn || (() => {})
        hook(context, meta, config)
      })
      return config
    },
    $clone () {
      return createFactory()
        .$combine(api)
        .$combine.apply(null, arguments)
    },
    $combine (...factories) {
      factories.forEach((f) => {
        const targetsKeys = targets.map((target) => target._key)
        const helpersKeys = helpers.map((helper) => helper.methodKey)
        const hooksFns = hooks.map((hook) => hook.fn)
        f._targets
          .filter((target) => target._key.indexOf('.') === -1)
          .filter((target) => targetsKeys.indexOf(target._key) === -1)
          .forEach((target) => api.$target(target._key, target._meta))
        f._helpers
          .filter((helper) => helpersKeys.indexOf(helper.methodKey) === -1)
          .forEach(({configKey, methodKey, arrayValue}) =>
            api.$helper(configKey, methodKey, arrayValue))
        f._hooks
          .filter((hook) => hooksFns.indexOf(hook.fn) === -1)
          .forEach(({fn, elseFn, meta}) => api.$hook(fn, elseFn, meta))
      })
      return api
    },
    $helper (configKey, methodKey, arrayValue = false) {
      if (typeof methodKey === 'boolean') {
        arrayValue = methodKey
        methodKey = undefined
      }
      methodKey = methodKey || configKey
      const helper = {configKey, methodKey, arrayValue}
      helpers.push(helper)
      mountHelper(api, helper)
      targets.forEach((target) => mountHelper(target, helper))
      return api
    },
    $hook (fn, elseFn, meta) {
      meta = meta || {}
      hooks.push({fn, elseFn, meta, metaKeys: Object.keys(meta)})
      return api
    },
    $set (key, value, elseValue, meta) {
      const fn = () => value
      const elseFn = elseValue && (() => elseValue)
      return api.$setWith(key, fn, elseFn, meta)
    },
    $setArray (key, value, elseValue, meta) {
      const fn = () => value
      const elseFn = elseValue && (() => elseValue)
      return api.$setArrayWith(key, fn, elseFn, meta)
    },
    $setArrayWith (key, fn, elseFn, meta) {
      const guards = (f) => (...args) => [].concat(f(...args) || [])
      fn = guards(fn)
      elseFn = elseFn && guards(elseFn)
      return api.$setWith(key, fn, elseFn, meta)
    },
    $setWith (key, fn, elseFn, meta) {
      return api.$hook(
        createSetterHook(key, fn),
        elseFn && createSetterHook(key, elseFn),
        meta
      )
    },
    // 94!
    $target (key, meta) {
      createSubFactory(api, key, meta)
      return this
    }
  }
  return api
}

function createSetterHook (configKey, fn) {
  return (context, meta, config) => {
    const value = fn(context, meta, config)
    const target = dotProp.get(config, configKey)
    const set = dotProp.set.bind(null, config, configKey)
    if (Array.isArray(target)) {
      set([].concat(target, value || []))
      return
    }
    if (typeof target === 'object') {
      merge(true, true, {}, target, value)
      return
    }
    set(value)
  }
}

function createSubFactory (superApi, key, meta) {
  const api = merge((fn) => { fn(api); return superApi }, {
    _key: key,
    _meta: meta,
    _metaKeys: Object.keys(meta),
    _superApi: superApi,
    $build (context, usrMeta, config) {
      return superApi.$build(context, merge({}, usrMeta, meta), config)
    },
    $hasAllMeta (testMeta) {
      return testMetaMatching(meta, testMeta, Object.keys(testMeta))
    },
    $hasMeta (testMeta, testMetaKeys) {
      return testMetaMatching(meta, testMeta, testMetaKeys)
    },
    $hasSomeMeta (testMeta, testMetaKeys) {
      return testMetaMatching(meta, testMeta, api._metaKeys)
    },
    $hook (fn, elseFn, usrMeta) {
      return superApi.$hook(fn, elseFn, merge({}, usrMeta, meta))
    },
    $set (key, value, elseValue, usrMeta) {
      return superApi.$set(key, value, elseValue, merge({}, usrMeta, meta))
    },
    $setArray (key, value, elseValue, usrMeta) {
      return superApi.$setArray(key, value, elseValue, merge({}, usrMeta, meta))
    },
    $setArrayWith (key, fn, elseFn, usrMeta) {
      return superApi.$setArrayWith(key, fn, elseFn, merge({}, usrMeta, meta))
    },
    $setWith (key, fn, elseFn, usrMeta) {
      return superApi.$setWith(key, fn, elseFn, merge({}, usrMeta, meta))
    }
  })

  superApi._helpers
    .forEach((helper) => mountHelper(api, helper))

  superApi._targets.push(api)
  dotProp.set(superApi, key, api)

  superApi._targets
    .filter((target) =>
      target._metaKeys
        .reduce((acc, targetMetaKey) =>
          acc && api._metaKeys.indexOf(targetMetaKey) === -1, true)
    )
    .forEach((target) => {
      const metaMixed = merge({}, target._meta, meta)
      createSubFactory(superApi, `${target._key}.${key}`, metaMixed)
      createSubFactory(superApi, `${key}.${target._key}`, metaMixed)
    })

  return api
}

function mountHelper (api, helper) {
  const superApi = api._superApi || api
  const {_meta: meta = {}} = api
  const {configKey: key, methodKey, arrayValue} = helper

  const [setter, setterWith] = arrayValue
    ? [superApi.$setArray, superApi.$setArrayWith]
    : [superApi.$set, superApi.$setWith]

  const fn = (value, elseValue) => setter(key, value, elseValue, meta)
  const fnWith = fn.with = (fn, elseFn) => setterWith(key, fn, elseFn, meta)

  dotProp.set(api, methodKey, fn)
  dotProp.set(api, methodKey + 'With', fnWith)
}

function testMetaMatching (meta, testMeta, testMetaKeys) {
  return [].concat(testMetaKeys || Object.keys(testMeta))
    .map((key) => [key, [].concat(testMeta[key])])
    .reduce((acc, [key, val]) => {
      const expected = [].concat(meta[key])
      return acc && val.reduce((ok, x) => ok || !!~expected.indexOf(x), false)
    }, true)
}

exports = module.exports = createFactory
exports.createSetterHook = createSetterHook
exports.createSubFactory = createSubFactory
exports.mountHelper = mountHelper
exports.testMetaMatching = testMetaMatching
